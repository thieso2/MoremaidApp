name: Release

on:
  push:
    tags: ["v*"]

env:
  APP_NAME: Moremaid
  SCHEME: Moremaid
  WORKSPACE: Moremaid.xcworkspace
  ENTITLEMENTS: Moremaid.entitlements

jobs:
  release:
    name: Build, Sign & Release
    runs-on: macos-26
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - uses: jdx/mise-action@v2

      - name: Extract version from tag
        id: version
        run: echo "version=${GITHUB_REF_NAME#v}" >> "$GITHUB_OUTPUT"

      - name: Install dependencies
        run: tuist install

      - name: Generate project
        run: tuist generate --no-open

      - name: Check signing secrets
        id: signing
        env:
          HAS_CERT: ${{ secrets.APPLE_CERTIFICATE_BASE64 != '' }}
          HAS_CERT_PASS: ${{ secrets.APPLE_CERTIFICATE_PASSWORD != '' }}
          HAS_DEV_ID: ${{ secrets.APPLE_DEVELOPER_ID != '' }}
        run: |
          if [ "$HAS_CERT" = "true" ] && [ "$HAS_CERT_PASS" = "true" ] && [ "$HAS_DEV_ID" = "true" ]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
          fi

      # --- Signed build path ---

      - name: Import signing certificate
        if: steps.signing.outputs.available == 'true'
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/signing.keychain-db"

          echo "$CERTIFICATE_BASE64" | base64 --decode > "$CERT_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed -e s/\"//g)
          security default-keychain -d user -s "$KEYCHAIN_PATH"

      - name: Verify certificate
        if: steps.signing.outputs.available == 'true'
        id: cert
        run: |
          echo "=== Keychains ==="
          security list-keychains -d user
          echo "=== Valid signing identities ==="
          security find-identity -v -p codesigning
          CERT_SHA=$(security find-identity -v -p codesigning | head -1 | awk '{print $2}')
          CERT_CN=$(security find-identity -v -p codesigning | head -1 | sed 's/.*"\(.*\)"/\1/')
          echo "cert_sha=$CERT_SHA" >> "$GITHUB_OUTPUT"
          echo "cert_cn=$CERT_CN" >> "$GITHUB_OUTPUT"
          echo "Using certificate: $CERT_CN ($CERT_SHA)"

      - name: Build (Release, signed)
        if: steps.signing.outputs.available == 'true'
        run: |
          tuist xcodebuild -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination 'platform=macOS' \
            -derivedDataPath .derivedData \
            CODE_SIGN_IDENTITY="${{ steps.cert.outputs.cert_cn }}" \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM= \
            build

      - name: Re-sign with entitlements
        if: steps.signing.outputs.available == 'true'
        run: |
          APP_PATH=".derivedData/Build/Products/Release/$APP_NAME.app"
          IDENTITY="${{ steps.cert.outputs.cert_cn }}"

          sign() {
            echo "Signing: $1"
            codesign --force --options runtime --timestamp --sign "$IDENTITY" "$@"
          }

          # Sign everything inside-out: deepest nested items first
          # 1. All dylibs
          find "$APP_PATH" -name '*.dylib' | while read -r item; do sign "$item"; done

          # 2. Nested bundles inside frameworks (XPC services, helper apps) â€” deepest first
          find "$APP_PATH/Contents/Frameworks" \( -name '*.xpc' -o -name '*.app' \) | sort -r | while read -r item; do
            sign "$item"
          done

          # 3. Standalone Mach-O executables inside frameworks (e.g. Sparkle's Autoupdate)
          find "$APP_PATH/Contents/Frameworks" -type f -perm +111 \
            ! -name '*.dylib' ! -path '*/MacOS/*' ! -path '*/Headers/*' \
            ! -path '*/Modules/*' ! -path '*/_CodeSignature/*' ! -name '*.plist' \
            ! -name '*.h' ! -name '*.modulemap' ! -name 'CodeResources' | while read -r item; do
            if file "$item" | grep -q Mach-O; then
              sign "$item"
            fi
          done

          # 4. Framework bundles
          find "$APP_PATH" -name '*.framework' | while read -r item; do sign "$item"; done

          # 5. App extensions
          find "$APP_PATH" -name '*.appex' | while read -r item; do sign "$item"; done

          # 6. CLI tool
          if [ -f "$APP_PATH/Contents/SharedSupport/bin/mm" ]; then
            sign "$APP_PATH/Contents/SharedSupport/bin/mm"
          fi

          # 7. Main app bundle with entitlements
          sign "$APP_PATH" --entitlements "$ENTITLEMENTS"

          # Verify
          codesign --verify --deep --strict "$APP_PATH"
          echo "Code signing verified successfully"

      - name: Notarize
        if: steps.signing.outputs.available == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
        run: |
          APP_PATH=".derivedData/Build/Products/Release/$APP_NAME.app"
          ZIP_PATH="$RUNNER_TEMP/notarize.zip"

          ditto -c -k --keepParent "$APP_PATH" "$ZIP_PATH"

          SUBMIT_OUT=$(xcrun notarytool submit "$ZIP_PATH" \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --wait 2>&1) || true
          echo "$SUBMIT_OUT"

          SUBMISSION_ID=$(echo "$SUBMIT_OUT" | grep "id:" | head -1 | awk '{print $2}')

          if echo "$SUBMIT_OUT" | grep -q "status: Invalid"; then
            echo "::error::Notarization rejected. Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --team-id "$APPLE_TEAM_ID" \
              --password "$APPLE_APP_PASSWORD" || true
            exit 1
          fi

          xcrun stapler staple "$APP_PATH"

      # --- Unsigned build path ---

      - name: Build (Release, unsigned)
        if: steps.signing.outputs.available != 'true'
        run: |
          tuist xcodebuild -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -configuration Release \
            -destination 'platform=macOS' \
            -derivedDataPath .derivedData \
            CODE_SIGN_IDENTITY="-" \
            build

      # --- Package & Release ---

      - name: Package ZIP
        id: package
        run: |
          APP_PATH=".derivedData/Build/Products/Release/$APP_NAME.app"
          VERSION="${{ steps.version.outputs.version }}"
          ZIP_NAME="${APP_NAME}-${VERSION}-macOS.zip"
          ditto -c -k --keepParent "$APP_PATH" "$ZIP_NAME"
          echo "zip_name=$ZIP_NAME" >> "$GITHUB_OUTPUT"
          echo "sha256=$(shasum -a 256 "$ZIP_NAME" | cut -d ' ' -f 1)" >> "$GITHUB_OUTPUT"

      - name: Sign update with Sparkle EdDSA
        if: steps.signing.outputs.available == 'true'
        id: sparkle_sign
        env:
          SPARKLE_EDDSA_PRIVATE_KEY: ${{ secrets.SPARKLE_EDDSA_PRIVATE_KEY }}
        run: |
          ZIP_NAME="${{ steps.package.outputs.zip_name }}"
          if [ -z "$SPARKLE_EDDSA_PRIVATE_KEY" ]; then
            echo "::warning::SPARKLE_EDDSA_PRIVATE_KEY not set, skipping Sparkle signing"
            echo "signature=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Download Sparkle tools
          SPARKLE_VERSION="2.7.0"
          curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz" -o "$RUNNER_TEMP/sparkle.tar.xz"
          mkdir -p "$RUNNER_TEMP/sparkle"
          tar -xf "$RUNNER_TEMP/sparkle.tar.xz" -C "$RUNNER_TEMP/sparkle"

          SIGN_UPDATE="$RUNNER_TEMP/sparkle/bin/sign_update"
          chmod +x "$SIGN_UPDATE"

          RAW=$(echo "$SPARKLE_EDDSA_PRIVATE_KEY" | "$SIGN_UPDATE" "$ZIP_NAME" --ed-key-file -)
          echo "Raw sign_update output: $RAW"
          # Extract edSignature value and length from output like:
          # sparkle:edSignature="abc==" length="123"
          ED_SIG=$(echo "$RAW" | sed -n 's/.*sparkle:edSignature="\([^"]*\)".*/\1/p')
          ED_LEN=$(echo "$RAW" | sed -n 's/.*length="\([^"]*\)".*/\1/p')
          echo "ed_signature=$ED_SIG" >> "$GITHUB_OUTPUT"
          echo "ed_length=$ED_LEN" >> "$GITHUB_OUTPUT"

      - name: Determine pre-release
        id: prerelease
        run: |
          if echo "${{ steps.version.outputs.version }}" | grep -qE '(alpha|beta|rc)'; then
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.package.outputs.zip_name }}
          generate_release_notes: true
          prerelease: ${{ steps.prerelease.outputs.is_prerelease }}
          body: |
            ## Install

            Download `${{ steps.package.outputs.zip_name }}`, unzip, and drag to Applications.

            **SHA-256:** `${{ steps.package.outputs.sha256 }}`

      # --- Sparkle appcast ---

      - name: Update appcast.xml
        if: steps.prerelease.outputs.is_prerelease == 'false' && steps.sparkle_sign.outputs.ed_signature != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          ZIP_NAME="${{ steps.package.outputs.zip_name }}"
          ED_SIG="${{ steps.sparkle_sign.outputs.ed_signature }}"
          ED_LEN="${{ steps.sparkle_sign.outputs.ed_length }}"
          REPO="thieso2/MoremaidApp"
          PUB_DATE=$(date -u -R)

          # Clone repo, update appcast, push
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${REPO}.git" "$RUNNER_TEMP/appcast-repo"
          cd "$RUNNER_TEMP/appcast-repo"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Insert new item before closing </channel> tag using python3
          python3 -c "
          import sys
          item = '''        <item>
              <title>Version ${VERSION}</title>
              <pubDate>${PUB_DATE}</pubDate>
              <sparkle:version>${VERSION}</sparkle:version>
              <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
              <sparkle:minimumSystemVersion>14.0</sparkle:minimumSystemVersion>
              <enclosure
                  url=\"https://github.com/${REPO}/releases/download/v${VERSION}/${ZIP_NAME}\"
                  sparkle:edSignature=\"${ED_SIG}\"
                  length=\"${ED_LEN}\"
                  type=\"application/octet-stream\" />
          </item>'''
          content = open('docs/appcast.xml').read()
          content = content.replace('</channel>', item + '\n    </channel>')
          open('docs/appcast.xml', 'w').write(content)
          "

          git add docs/appcast.xml
          git commit -m "Update appcast for v${VERSION}"
          git push

      # --- Homebrew tap ---

      - name: Update Homebrew tap
        if: steps.prerelease.outputs.is_prerelease == 'false' && env.HOMEBREW_TAP_TOKEN != ''
        env:
          HOMEBREW_TAP_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SHA256="${{ steps.package.outputs.sha256 }}"
          ZIP_NAME="${{ steps.package.outputs.zip_name }}"
          REPO="thieso2/MoremaidApp"

          CASK_CONTENT=$(cat <<'CASK_EOF'
          cask "moremaidapp" do
            version "VERSION_PLACEHOLDER"
            sha256 "SHA256_PLACEHOLDER"

            url "https://github.com/REPO_PLACEHOLDER/releases/download/v#{version}/ZIP_PLACEHOLDER",
                verified: "github.com/REPO_PLACEHOLDER/"

            name "Moremaid"
            desc "Markdown viewer for macOS"
            homepage "https://github.com/REPO_PLACEHOLDER"

            depends_on macos: ">= :tahoe"

            app "Moremaid.app"

            zap trash: [
              "~/Library/Preferences/de.tmp8.moremaid.plist",
            ]
          end
          CASK_EOF
          )

          CASK_CONTENT="${CASK_CONTENT//VERSION_PLACEHOLDER/$VERSION}"
          CASK_CONTENT="${CASK_CONTENT//SHA256_PLACEHOLDER/$SHA256}"
          CASK_CONTENT="${CASK_CONTENT//REPO_PLACEHOLDER/$REPO}"
          CASK_CONTENT="${CASK_CONTENT//ZIP_PLACEHOLDER/$ZIP_NAME}"

          # Clone tap, update cask, push
          git clone "https://x-access-token:${HOMEBREW_TAP_TOKEN}@github.com/thieso2/homebrew-tap.git" "$RUNNER_TEMP/homebrew-tap"
          mkdir -p "$RUNNER_TEMP/homebrew-tap/Casks"
          echo "$CASK_CONTENT" > "$RUNNER_TEMP/homebrew-tap/Casks/moremaidapp.rb"

          cd "$RUNNER_TEMP/homebrew-tap"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Casks/moremaidapp.rb
          git commit -m "Update moremaidapp to $VERSION" || echo "No changes to commit"
          git push

      # --- Cleanup ---

      - name: Cleanup keychain
        if: always() && steps.signing.outputs.available == 'true'
        run: security delete-keychain "$RUNNER_TEMP/signing.keychain-db" 2>/dev/null || true
